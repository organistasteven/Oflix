security:
    enable_authenticator_manager: true
    # https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords
    password_hashers:
        Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface: 'auto'
    # https://symfony.com/doc/current/security.html#loading-the-user-the-user-provider
    providers:
        # used to reload user from session & other features (e.g. switch_user)
        app_user_provider:
            entity:
                class: App\Entity\User
                property: email
    firewalls:

        # connexion en JSON avec LexikJWT
        login:
            pattern: ^/api/login
            stateless: true
            json_login:
                check_path: /api/login_check
                success_handler: lexik_jwt_authentication.handler.authentication_success
                failure_handler: lexik_jwt_authentication.handler.authentication_failure

        # firewall pour les routes de l'API (JWT sera actif sur ces routes)
        api:
            # tous les "path" qui commencent par /api
            pattern:   ^/api
            stateless: true
            jwt: ~

        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
        main:
            lazy: true
            provider: app_user_provider

            # activate different ways to authenticate
            # https://symfony.com/doc/current/security.html#the-firewall
            form_login:
                # "app_login" is the name of the route created previously
                # GET route
                login_path: app_login
                # POST route
                check_path: app_login
            
            # https://symfony.com/doc/5.4/security.html#logging-out
            logout:
                # nom de la route qui va déclencher la déconnexion
                # que le composant de sécurité prend en charge
                path: app_logout
                # redirection après logout (par défaut on retourne sur /)
                # https://symfony.com/doc/current/reference/configuration/security.html#target
                target: /login

            # https://symfony.com/doc/current/security/impersonating_user.html
            # switch_user: true

    # Easy way to control access for large sections of your site
    # Note: Only the *first* access control that matches will be used
    access_control:

        # routes de l'API
        # create movie
        - { path: ^/api/movies, roles: ROLE_ADMIN, methods: POST }
        # update movie
        - { path: ^/api/movies/\d+, roles: ROLE_ADMIN, methods: PATCH }

        # on restreint les accès front

        #   review_add                      GET|POST   ANY      ANY    /review/add/{movieId}              
        #   favoris                         ANY        ANY      ANY    /favoris                           

        - { path: ^/review/add/\d+, roles: ROLE_USER, methods: [GET, POST] }
        - { path: ^/favoris, roles: ROLE_USER, methods: GET }

        # on restreint les accès admin

        # on fait un console debug:router pour identifier les chemins à protéger
        #   app_backoffice_casting_index    GET        ANY      ANY    /backoffice/casting/               
        #   app_backoffice_casting_new      GET|POST   ANY      ANY    /backoffice/casting/new            
        #   app_backoffice_casting_show     GET        ANY      ANY    /backoffice/casting/{id}           
        #   app_backoffice_casting_edit     GET|POST   ANY      ANY    /backoffice/casting/{id}/edit      
        #   app_backoffice_casting_delete   POST       ANY      ANY    /backoffice/casting/{id}           

        # new
        - { path: ^/backoffice/(casting|genre|movie|season|user)/new, roles: ROLE_ADMIN, methods: [GET, POST] }
        # edit
        - { path: ^/backoffice/(casting|genre|movie|season|user)/\d+/edit, roles: ROLE_ADMIN, methods: [GET, POST] }
        # delete => ici la méthode POST est vraiment nécessaire, car en GET cela correspond à l'action "show" valide pour ROLE_MANAGER
        - { path: ^/backoffice/(casting|genre|movie|season|user)/\d+, roles: ROLE_ADMIN, methods: POST }
        # le manager est le rôle minimum pour rentrer sur le back-office
        - { path: ^/backoffice, roles: ROLE_MANAGER }

    # si on souhaite que chaque rôle hérite des permissions du précédent
    # => parce que notre projet s'y prête (PARCE QUE C'EST NOTRE PROJEEEEEEEEEET !)
    role_hierarchy:
        # le manager a les mêmes permissions que le simple utilisateur
        ROLE_MANAGER: ROLE_USER
        # l'admin hérite des permissions du manager (et en cascade, du simple utilisateur)
        ROLE_ADMIN: ROLE_MANAGER




when@test:
    security:
        password_hashers:
            # By default, password hashers are resource intensive and take time. This is
            # important to generate secure password hashes. In tests however, secure hashes
            # are not important, waste resources and increase test times. The following
            # reduces the work factor to the lowest possible values.
            Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface:
                algorithm: auto
                cost: 4 # Lowest possible value for bcrypt
                time_cost: 3 # Lowest possible value for argon
                memory_cost: 10 # Lowest possible value for argon
